digraph SPARC_METHODOLOGY_WORKFLOW {
  // Layout configuration
  rankdir=TB;
  node [shape=box, style="rounded,filled"];

  // =============================================================================
  // INITIALIZATION PHASE
  // =============================================================================
  subgraph cluster_initialization {
    label="SPARC Initialization";
    style="filled,rounded";
    color="lightblue";
    bgcolor="#E8F4F8";

    start [label="SPARC Workflow Invoked", shape=ellipse, fillcolor=lightblue];
    load_spec [label="Load Feature Requirements"];
    validate_input [label="Validate Project Context"];
    check_deps [label="Check SPARC Agent Availability\nSpec, Pseudocode, Architect, etc."];

    start -> load_spec;
    load_spec -> validate_input;
    validate_input -> check_deps;
  }

  // =============================================================================
  // VALIDATION & POLICY ENFORCEMENT
  // =============================================================================
  subgraph cluster_validation {
    label="Policy Validation";
    style="filled,rounded";
    color="orange";
    bgcolor="#FFF8E8";

    check_policy [shape=diamond, label="12-FA\nCompliant?"];
    check_secrets [shape=diamond, label="No Secrets\nin Root?"];

    policy_violation [shape=octagon, fillcolor=crimson,
                      label="BLOCKED\nPolicy Violation"];
    secrets_violation [shape=octagon, fillcolor=crimson,
                       label="BLOCKED\nRule #1: No Secrets in Root"];
  }

  // Connect initialization to validation
  check_deps -> check_policy;
  check_policy -> check_secrets [label="Pass"];
  check_policy -> policy_violation [label="Fail"];
  check_secrets -> secrets_violation [label="Secrets Found"];

  // =============================================================================
  // PHASE 1: SPECIFICATION
  // =============================================================================
  subgraph cluster_specification {
    label="Phase 1: Specification";
    style="filled,rounded";
    color="purple";
    bgcolor="#F0E8F8";

    spec_start [label="Specification Phase\nRequirements Analysis", fillcolor=purple];
    gather_requirements [label="Gather Requirements\nUser Stories, Constraints", fillcolor=purple];
    define_scope [label="Define Scope\nBoundaries, Success Criteria", fillcolor=purple];
    decision_spec [shape=diamond, label="Spec\nComplete?"];

    spec_error [shape=octagon, fillcolor=orange,
                label="Incomplete Specification"];
  }

  // Connect validation to specification
  check_secrets -> spec_start [label="Pass"];

  // Specification flow
  spec_start -> gather_requirements;
  gather_requirements -> define_scope;
  define_scope -> decision_spec;
  decision_spec -> spec_error [label="No"];
  spec_error -> gather_requirements [label="Refine", style=dashed];

  // =============================================================================
  // PHASE 2: PSEUDOCODE
  // =============================================================================
  subgraph cluster_pseudocode {
    label="Phase 2: Pseudocode";
    style="filled,rounded";
    color="darkviolet";
    bgcolor="#F8E8FF";

    pseudo_start [label="Pseudocode Phase\nAlgorithm Design", fillcolor=darkviolet];
    design_algorithms [label="Design Core Algorithms\nStep-by-Step Logic", fillcolor=darkviolet];
    identify_patterns [label="Identify Design Patterns\nReusability", fillcolor=darkviolet];
    decision_pseudo [shape=diamond, label="Pseudocode\nValid?"];

    pseudo_error [shape=octagon, fillcolor=orange,
                  label="Pseudocode Issues"];
  }

  // Connect specification to pseudocode
  decision_spec -> pseudo_start [label="Yes"];

  // Pseudocode flow
  pseudo_start -> design_algorithms;
  design_algorithms -> identify_patterns;
  identify_patterns -> decision_pseudo;
  decision_pseudo -> pseudo_error [label="No"];
  pseudo_error -> design_algorithms [label="Refine", style=dashed];

  // =============================================================================
  // PHASE 3: ARCHITECTURE
  // =============================================================================
  subgraph cluster_architecture {
    label="Phase 3: Architecture";
    style="filled,rounded";
    color="blue";
    bgcolor="#E8E8F8";

    arch_start [label="Architecture Phase\nSystem Design", fillcolor=lightblue];
    design_components [label="Design Components\nModules, Interfaces", fillcolor=lightblue];
    define_contracts [label="Define Contracts\nAPIs, Data Structures", fillcolor=lightblue];
    decision_arch [shape=diamond, label="Architecture\nSound?"];

    arch_error [shape=octagon, fillcolor=orange,
                label="Architecture Issues"];
  }

  // Connect pseudocode to architecture
  decision_pseudo -> arch_start [label="Yes"];

  // Architecture flow
  arch_start -> design_components;
  design_components -> define_contracts;
  define_contracts -> decision_arch;
  decision_arch -> arch_error [label="No"];
  arch_error -> design_components [label="Refine", style=dashed];

  // =============================================================================
  // PHASE 4: REFINEMENT (TDD)
  // =============================================================================
  subgraph cluster_refinement {
    label="Phase 4: Refinement (TDD)";
    style="filled,rounded";
    color="green";
    bgcolor="#E8F8E8";

    refine_start [label="Refinement Phase\nTest-Driven Development", fillcolor=lightgreen];
    write_tests [label="Write Tests First\nUnit, Integration", fillcolor=lightgreen];
    implement_code [label="Implement Code\nPass Tests", fillcolor=lightgreen];
    refactor_code [label="Refactor Code\nClean Up", fillcolor=lightgreen];
    decision_refine [shape=diamond, label="All Tests\nPass?"];

    refine_error [shape=octagon, fillcolor=orange,
                  label="Tests Failing"];
  }

  // Connect architecture to refinement
  decision_arch -> refine_start [label="Yes"];

  // Refinement flow
  refine_start -> write_tests;
  write_tests -> implement_code;
  implement_code -> refactor_code;
  refactor_code -> decision_refine;
  decision_refine -> refine_error [label="No"];
  refine_error -> implement_code [label="Fix", style=dashed];

  // =============================================================================
  // PHASE 5: COMPLETION
  // =============================================================================
  subgraph cluster_completion_phase {
    label="Phase 5: Completion";
    style="filled,rounded";
    color="darkgreen";
    bgcolor="#D0F0D0";

    complete_start [label="Completion Phase\nIntegration & Deployment", fillcolor=darkgreen];
    integrate_components [label="Integrate Components\nSystem Assembly", fillcolor=darkgreen];
    run_e2e_tests [label="Run End-to-End Tests\nFull System Validation", fillcolor=darkgreen];
    decision_complete [shape=diamond, label="System\nReady?"];

    complete_error [shape=octagon, fillcolor=orange,
                    label="Integration Issues"];
  }

  // Connect refinement to completion
  decision_refine -> complete_start [label="Yes"];

  // Completion flow
  complete_start -> integrate_components;
  integrate_components -> run_e2e_tests;
  run_e2e_tests -> decision_complete;
  decision_complete -> complete_error [label="No"];
  complete_error -> integrate_components [label="Fix", style=dashed];

  // =============================================================================
  // COORDINATION & MEMORY
  // =============================================================================
  subgraph cluster_coordination {
    label="SPARC Coordination";
    style="filled,rounded";
    color="blue";
    bgcolor="#E8E8F8";

    memory_store [label="Store SPARC Artifacts\nSpec, Pseudocode, Architecture", fillcolor=lightblue];
    notify_coordinator [label="Notify Coordinator\nSPARC Complete", fillcolor=lightblue];
    check_dependencies [shape=diamond, label="Dependent\nWorkflows?"];
  }

  // Connect completion to coordination
  decision_complete -> memory_store [label="Yes"];
  memory_store -> notify_coordinator;
  notify_coordinator -> check_dependencies;

  // =============================================================================
  // VALIDATION & QUALITY GATES
  // =============================================================================
  subgraph cluster_quality {
    label="Quality Validation";
    style="filled,rounded";
    color="green";
    bgcolor="#E8F8E8";

    validate_output [shape=diamond, label="All Phases\nComplete?"];
    run_tests [label="Run Quality Tests\nCode Quality, Coverage", fillcolor=lightgreen];
    test_results [shape=diamond, label="Quality\nAcceptable?"];

    quality_gate_fail [shape=octagon, fillcolor=orange,
                       label="Quality Gate Failed"];
  }

  // Connect coordination to quality
  check_dependencies -> validate_output [label="No"];

  // Quality flow
  validate_output -> run_tests [label="Yes"];
  validate_output -> quality_gate_fail [label="No"];

  run_tests -> test_results;
  test_results -> quality_gate_fail [label="Fail"];

  // =============================================================================
  // COMPLETION & CLEANUP
  // =============================================================================
  subgraph cluster_completion {
    label="Final Completion";
    style="filled,rounded";
    color="green";
    bgcolor="#E8F8E8";

    cleanup [label="Cleanup Resources", fillcolor=lightgreen];
    log_completion [label="Log SPARC Metrics\nPhase Durations, Quality"];
    success [label="SPARC Complete\nProduction Ready", shape=doublecircle,
             fillcolor=green, style="filled,bold"];
  }

  // Connect quality to completion
  test_results -> cleanup [label="Pass"];
  cleanup -> log_completion;
  log_completion -> success;

  // =============================================================================
  // ERROR ESCALATION PATH
  // =============================================================================
  subgraph cluster_errors {
    label="Error Handling & Escalation";
    style="filled,rounded";
    color="red";
    bgcolor="#F8E8E8";

    escalate [shape=hexagon, fillcolor=yellow,
              label="Escalate to User"];
    log_error [label="Log Error Details\nPhase, Issue", fillcolor=orange];
    rollback [label="Rollback to Previous Phase", fillcolor=orange];
    failure [label="SPARC Failed", shape=doublecircle,
             fillcolor=red, style="filled,bold"];
  }

  // Error escalation flow
  spec_error -> escalate;
  pseudo_error -> escalate;
  arch_error -> escalate;
  refine_error -> escalate;
  complete_error -> escalate;
  escalate -> log_error;
  quality_gate_fail -> log_error;
  policy_violation -> log_error;
  secrets_violation -> log_error;

  log_error -> rollback;
  rollback -> failure;

  // =============================================================================
  // LEGEND
  // =============================================================================
  subgraph cluster_legend {
    label="Legend";
    rank=sink;
    style="filled,rounded";
    bgcolor="#F8F8F8";

    legend_start [shape=ellipse, label="Entry Point", fillcolor=lightblue];
    legend_decision [shape=diamond, label="Decision"];
    legend_process [shape=box, label="Process", fillcolor=purple];
    legend_block [shape=octagon, fillcolor=crimson, label="Blocker"];
    legend_warn [shape=octagon, fillcolor=orange, label="Warning"];
    legend_manual [shape=hexagon, fillcolor=yellow, label="Manual"];
    legend_success [shape=doublecircle, fillcolor=green, label="Success"];
    legend_failure [shape=doublecircle, fillcolor=red, label="Failure"];

    legend_start -> legend_decision [style=invis];
    legend_decision -> legend_process [style=invis];
    legend_process -> legend_block [style=invis];
    legend_block -> legend_warn [style=invis];
    legend_warn -> legend_manual [style=invis];
    legend_manual -> legend_success [style=invis];
    legend_success -> legend_failure [style=invis];
  }
}
