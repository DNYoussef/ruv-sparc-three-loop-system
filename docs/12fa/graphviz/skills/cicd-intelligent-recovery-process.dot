digraph CICD_INTELLIGENT_RECOVERY_WORKFLOW {
  // Layout configuration
  rankdir=TB;
  node [shape=box, style="rounded,filled"];

  // =============================================================================
  // INITIALIZATION PHASE
  // =============================================================================
  subgraph cluster_initialization {
    label="Loop 3 Initialization";
    style="filled,rounded";
    color="lightblue";
    bgcolor="#E8F4F8";

    start [label="Loop 3: CI/CD Invoked", shape=ellipse, fillcolor=lightblue];
    load_impl [label="Retrieve Implementation\nfrom Loop 2"];
    validate_input [label="Validate Test Environment\nDependencies"];
    check_deps [label="Check Gemini 2M Context\n7-Agent Availability"];

    start -> load_impl;
    load_impl -> validate_input;
    validate_input -> check_deps;
  }

  // =============================================================================
  // VALIDATION & POLICY ENFORCEMENT
  // =============================================================================
  subgraph cluster_validation {
    label="Policy Validation";
    style="filled,rounded";
    color="orange";
    bgcolor="#FFF8E8";

    check_policy [shape=diamond, label="12-FA\nCompliant?"];
    check_secrets [shape=diamond, label="No Secrets\nin Root?"];

    policy_violation [shape=octagon, fillcolor=crimson,
                      label="BLOCKED\nPolicy Violation"];
    secrets_violation [shape=octagon, fillcolor=crimson,
                       label="BLOCKED\nRule #1: No Secrets in Root"];
  }

  // Connect initialization to validation
  check_deps -> check_policy;
  check_policy -> check_secrets [label="Pass"];
  check_policy -> policy_violation [label="Fail"];
  check_secrets -> secrets_violation [label="Secrets Found"];

  // =============================================================================
  // EXECUTION PHASE: CI/CD PIPELINE
  // =============================================================================
  subgraph cluster_cicd {
    label="CI/CD Pipeline Execution";
    style="filled,rounded";
    color="purple";
    bgcolor="#F0E8F8";

    run_unit_tests [label="Run Unit Tests\nParallel Execution", fillcolor=purple];
    run_integration_tests [label="Run Integration Tests\nE2E Scenarios", fillcolor=purple];
    run_security_scan [label="Run Security Scan\nVulnerability Detection", fillcolor=purple];
    run_performance_tests [label="Run Performance Tests\nLoad, Stress", fillcolor=purple];

    decision_tests [shape=diamond, label="All Tests\nPass?"];
  }

  // Connect validation to CI/CD
  check_secrets -> run_unit_tests [label="Pass"];

  // CI/CD flow
  run_unit_tests -> run_integration_tests;
  run_integration_tests -> run_security_scan;
  run_security_scan -> run_performance_tests;
  run_performance_tests -> decision_tests;

  // =============================================================================
  // FAILURE ANALYSIS: 7-AGENT SWARM
  // =============================================================================
  subgraph cluster_failure_analysis {
    label="7-Agent Failure Analysis";
    style="filled,rounded";
    color="red";
    bgcolor="#FFF0F0";

    spawn_analysts [label="Spawn 7 Analysis Agents\nRoot Cause, Dependency\nSecurity, Performance\nIntegration, Test, Code", fillcolor=orange];
    gemini_megacontext [label="Load Full Context\nGemini 2M Token Window", fillcolor=orange];
    parallel_analysis [label="Parallel Root Cause Analysis\nDeep Trace Analysis", fillcolor=orange];
    consensus_analysis [label="Byzantine Consensus\nFailure Identification", fillcolor=orange];

    decision_root_cause [shape=diamond, label="Root Cause\nIdentified?"];
    analysis_fail [shape=octagon, fillcolor=crimson,
                   label="Cannot Identify Root Cause"];
  }

  // Connect tests to failure analysis
  decision_tests -> spawn_analysts [label="Fail"];

  // Analysis flow
  spawn_analysts -> gemini_megacontext;
  gemini_megacontext -> parallel_analysis;
  parallel_analysis -> consensus_analysis;
  consensus_analysis -> decision_root_cause;
  decision_root_cause -> analysis_fail [label="No"];

  // =============================================================================
  // INTELLIGENT RECOVERY
  // =============================================================================
  subgraph cluster_recovery {
    label="Intelligent Recovery";
    style="filled,rounded";
    color="green";
    bgcolor="#E8FFE8";

    generate_fix [label="Generate Automated Fix\nCode Patches", fillcolor=lightgreen];
    apply_fix [label="Apply Fix\nUpdate Implementation", fillcolor=lightgreen];
    rerun_tests [label="Re-run Full Test Suite", fillcolor=lightgreen];
    decision_retry [shape=diamond, label="Tests Pass\nNow?"];

    max_retries [shape=diamond, label="Max Retries\nReached?"];
    recovery_fail [shape=octagon, fillcolor=orange,
                   label="Recovery Failed"];
  }

  // Connect analysis to recovery
  decision_root_cause -> generate_fix [label="Yes"];

  // Recovery flow
  generate_fix -> apply_fix;
  apply_fix -> rerun_tests;
  rerun_tests -> decision_retry;
  decision_retry -> max_retries [label="Fail"];
  max_retries -> spawn_analysts [label="No", style=dashed];
  max_retries -> recovery_fail [label="Yes"];

  // =============================================================================
  // FEEDBACK TO LOOP 1
  // =============================================================================
  subgraph cluster_feedback {
    label="Feedback to Loop 1";
    style="filled,rounded";
    color="cyan";
    bgcolor="#E8FFFF";

    extract_patterns [label="Extract Failure Patterns\nCommon Issues", fillcolor=cyan];
    store_feedback [label="Store in Memory\nfeedback/{task-id}/patterns", fillcolor=cyan];
    notify_loop1 [label="Notify Loop 1\nresearch-driven-planning", fillcolor=cyan];
  }

  // Connect recovery to feedback
  recovery_fail -> extract_patterns;
  extract_patterns -> store_feedback;
  store_feedback -> notify_loop1;

  // =============================================================================
  // COORDINATION & MEMORY
  // =============================================================================
  subgraph cluster_coordination {
    label="Quality Validation Complete";
    style="filled,rounded";
    color="blue";
    bgcolor="#E8E8F8";

    memory_store [label="Store Validation Results\nquality/{task-id}/validation", fillcolor=lightblue];
    notify_coordinator [label="Notify System\n100% Success", fillcolor=lightblue];
    check_dependencies [shape=diamond, label="All Loops\nComplete?"];
  }

  // Connect tests to coordination
  decision_tests -> memory_store [label="Pass"];
  decision_retry -> memory_store [label="Pass"];
  memory_store -> notify_coordinator;
  notify_coordinator -> check_dependencies;

  // =============================================================================
  // VALIDATION & QUALITY GATES
  // =============================================================================
  subgraph cluster_quality {
    label="Final Quality Gates";
    style="filled,rounded";
    color="green";
    bgcolor="#E8F8E8";

    validate_output [shape=diamond, label="100% Test\nSuccess?"];
    theater_validation [label="Run Theater Validation\nEnsure Real Tests", fillcolor=lightgreen];
    theater_check [shape=diamond, label="No Theater?"];

    quality_gate_fail [shape=octagon, fillcolor=orange,
                       label="Quality Gate Failed"];
  }

  // Connect coordination to quality
  check_dependencies -> validate_output [label="Yes"];

  // Quality flow
  validate_output -> theater_validation [label="Yes"];
  validate_output -> quality_gate_fail [label="No"];

  theater_validation -> theater_check;
  theater_check -> quality_gate_fail [label="Theater Detected"];

  // =============================================================================
  // COMPLETION & CLEANUP
  // =============================================================================
  subgraph cluster_completion {
    label="Loop 3 Completion";
    style="filled,rounded";
    color="green";
    bgcolor="#E8F8E8";

    cleanup [label="Cleanup Resources", fillcolor=lightgreen];
    log_completion [label="Log Metrics\nTest Success Rate\nRecovery Attempts"];
    success [label="Loop 3 Complete\n100% Test Success", shape=doublecircle,
             fillcolor=green, style="filled,bold"];
  }

  // Connect quality to completion
  theater_check -> cleanup [label="Pass"];
  cleanup -> log_completion;
  log_completion -> success;

  // =============================================================================
  // ERROR ESCALATION PATH
  // =============================================================================
  subgraph cluster_errors {
    label="Error Handling & Escalation";
    style="filled,rounded";
    color="red";
    bgcolor="#F8E8E8";

    escalate [shape=hexagon, fillcolor=yellow,
              label="Escalate to User"];
    log_error [label="Log Error Details", fillcolor=orange];
    rollback [label="Rollback Changes", fillcolor=orange];
    failure [label="Loop 3 Failed", shape=doublecircle,
             fillcolor=red, style="filled,bold"];
  }

  // Error escalation flow
  escalate -> log_error;
  quality_gate_fail -> log_error;
  policy_violation -> log_error;
  secrets_violation -> log_error;
  analysis_fail -> log_error;

  log_error -> rollback;
  rollback -> failure;

  // =============================================================================
  // LEGEND
  // =============================================================================
  subgraph cluster_legend {
    label="Legend";
    rank=sink;
    style="filled,rounded";
    bgcolor="#F8F8F8";

    legend_start [shape=ellipse, label="Entry Point", fillcolor=lightblue];
    legend_decision [shape=diamond, label="Decision"];
    legend_process [shape=box, label="Process", fillcolor=purple];
    legend_block [shape=octagon, fillcolor=crimson, label="Blocker"];
    legend_warn [shape=octagon, fillcolor=orange, label="Warning"];
    legend_manual [shape=hexagon, fillcolor=yellow, label="Manual"];
    legend_success [shape=doublecircle, fillcolor=green, label="Success"];
    legend_failure [shape=doublecircle, fillcolor=red, label="Failure"];

    legend_start -> legend_decision [style=invis];
    legend_decision -> legend_process [style=invis];
    legend_process -> legend_block [style=invis];
    legend_block -> legend_warn [style=invis];
    legend_warn -> legend_manual [style=invis];
    legend_manual -> legend_success [style=invis];
    legend_success -> legend_failure [style=invis];
  }
}
