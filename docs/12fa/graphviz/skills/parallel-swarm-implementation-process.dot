digraph PARALLEL_SWARM_IMPLEMENTATION_WORKFLOW {
  // Layout configuration
  rankdir=TB;
  node [shape=box, style="rounded,filled"];

  // =============================================================================
  // INITIALIZATION PHASE
  // =============================================================================
  subgraph cluster_initialization {
    label="Loop 2 Initialization";
    style="filled,rounded";
    color="lightblue";
    bgcolor="#E8F4F8";

    start [label="Loop 2: Implementation Invoked", shape=ellipse, fillcolor=lightblue];
    load_plan [label="Retrieve Plan from Loop 1\nplanning/{task-id}/requirements"];
    validate_input [label="Validate Plan Structure\nAgent Requirements"];
    check_registry [label="Check 86-Agent Registry\nAvailability"];

    start -> load_plan;
    load_plan -> validate_input;
    validate_input -> check_registry;
  }

  // =============================================================================
  // VALIDATION & POLICY ENFORCEMENT
  // =============================================================================
  subgraph cluster_validation {
    label="Policy Validation";
    style="filled,rounded";
    color="orange";
    bgcolor="#FFF8E8";

    check_policy [shape=diamond, label="12-FA\nCompliant?"];
    check_secrets [shape=diamond, label="No Secrets\nin Root?"];

    policy_violation [shape=octagon, fillcolor=crimson,
                      label="BLOCKED\nPolicy Violation"];
    secrets_violation [shape=octagon, fillcolor=crimson,
                       label="BLOCKED\nRule #1: No Secrets in Root"];
  }

  // Connect initialization to validation
  check_registry -> check_policy;
  check_policy -> check_secrets [label="Pass"];
  check_policy -> policy_violation [label="Fail"];
  check_secrets -> secrets_violation [label="Secrets Found"];

  // =============================================================================
  // META-SKILL: DYNAMIC COMPILATION
  // =============================================================================
  subgraph cluster_compilation {
    label="META-SKILL: Dynamic Compilation";
    style="filled,rounded";
    color="purple";
    bgcolor="#F0E8F8";

    parse_plan [label="Parse Plan into Tasks\nExtract Dependencies", fillcolor=purple];
    build_graph [label="Build Execution Graph\nAgent-Skill Matrix", fillcolor=purple];
    select_agents [label="Select Optimal Agents\nfrom 86-Agent Registry", fillcolor=purple];
    assign_skills [label="Assign Skills to Agents\n(if available)", fillcolor=purple];
    decision_compilation [shape=diamond, label="Graph Valid?"];

    compilation_error [shape=octagon, fillcolor=orange,
                       label="Compilation Error"];
  }

  // Connect validation to compilation
  check_secrets -> parse_plan [label="Pass"];

  // Compilation flow
  parse_plan -> build_graph;
  build_graph -> select_agents;
  select_agents -> assign_skills;
  assign_skills -> decision_compilation;
  decision_compilation -> compilation_error [label="No"];

  // =============================================================================
  // EXECUTION PHASE: 9-STEP SWARM
  // =============================================================================
  subgraph cluster_execution {
    label="9-Step Swarm Execution";
    style="filled,rounded";
    color="darkgreen";
    bgcolor="#E8F8E8";

    step1_init [label="Step 1: Initialize Swarm\nTopology Selection", fillcolor=lightgreen];
    step2_spawn [label="Step 2: Spawn Agents\nParallel Initialization", fillcolor=lightgreen];
    step3_assign [label="Step 3: Task Assignment\nLoad Balancing", fillcolor=lightgreen];
    step4_execute [label="Step 4: Parallel Execution\n8.3x Speedup", fillcolor=lightgreen];
    step5_coordinate [label="Step 5: Agent Coordination\nMemory Sharing", fillcolor=lightgreen];
    step6_monitor [label="Step 6: Progress Monitoring\nReal-time Tracking", fillcolor=lightgreen];
    step7_validate [label="Step 7: Output Validation\nQuality Checks", fillcolor=lightgreen];
    step8_theater [label="Step 8: Theater Detection\nReality Validation", fillcolor=lightgreen];
    step9_integrate [label="Step 9: Integration\nMerge Results", fillcolor=lightgreen];

    decision_execution [shape=diamond, label="Execution\nSuccess?"];
    execution_error [shape=octagon, fillcolor=orange,
                     label="Execution Error"];
  }

  // Connect compilation to execution
  decision_compilation -> step1_init [label="Yes"];

  // Execution flow
  step1_init -> step2_spawn;
  step2_spawn -> step3_assign;
  step3_assign -> step4_execute;
  step4_execute -> step5_coordinate;
  step5_coordinate -> step6_monitor;
  step6_monitor -> step7_validate;
  step7_validate -> step8_theater;
  step8_theater -> step9_integrate;
  step9_integrate -> decision_execution;
  decision_execution -> execution_error [label="No"];

  // =============================================================================
  // THEATER DETECTION
  // =============================================================================
  subgraph cluster_theater {
    label="Theater Detection";
    style="filled,rounded";
    color="red";
    bgcolor="#FFF0F0";

    theater_check [label="Run Theater Detection\nCompletion, Mock, Test", fillcolor=orange];
    decision_theater [shape=diamond, label="Theater\nDetected?"];
    theater_alert [shape=octagon, fillcolor=crimson,
                   label="THEATER DETECTED\nZero Tolerance"];
    theater_debug [label="Debug Theater Source\nIdentify Fake Output", fillcolor=yellow];
  }

  // Connect execution to theater detection
  step8_theater -> theater_check;
  theater_check -> decision_theater;
  decision_theater -> theater_alert [label="Yes"];
  theater_alert -> theater_debug;
  theater_debug -> escalate;

  // =============================================================================
  // COORDINATION & MEMORY
  // =============================================================================
  subgraph cluster_coordination {
    label="Handoff to Loop 3";
    style="filled,rounded";
    color="blue";
    bgcolor="#E8E8F8";

    memory_store [label="Store Implementation\nimplementation/{task-id}/outputs", fillcolor=lightblue];
    notify_loop3 [label="Notify Loop 3\ncicd-intelligent-recovery", fillcolor=lightblue];
    check_dependencies [shape=diamond, label="Loop 3\nReady?"];
  }

  // Connect execution to coordination
  decision_execution -> memory_store [label="Yes"];
  decision_theater -> memory_store [label="No Theater"];
  memory_store -> notify_loop3;
  notify_loop3 -> check_dependencies;

  // =============================================================================
  // VALIDATION & QUALITY GATES
  // =============================================================================
  subgraph cluster_quality {
    label="Quality Validation";
    style="filled,rounded";
    color="green";
    bgcolor="#E8F8E8";

    validate_output [shape=diamond, label="Output Complete?"];
    run_tests [label="Run Integration Tests", fillcolor=lightgreen];
    test_results [shape=diamond, label="Tests Pass?"];

    quality_gate_fail [shape=octagon, fillcolor=orange,
                       label="Quality Gate Failed"];
  }

  // Connect coordination to quality
  check_dependencies -> validate_output [label="Ready"];

  // Quality flow
  validate_output -> run_tests [label="Yes"];
  validate_output -> quality_gate_fail [label="No"];

  run_tests -> test_results;
  test_results -> quality_gate_fail [label="Fail"];

  // =============================================================================
  // COMPLETION & CLEANUP
  // =============================================================================
  subgraph cluster_completion {
    label="Loop 2 Completion";
    style="filled,rounded";
    color="green";
    bgcolor="#E8F8E8";

    cleanup [label="Cleanup Resources\nTerminate Agents", fillcolor=lightgreen];
    log_completion [label="Log Metrics\nSpeedup, Agent Count\nTheater Detection"];
    success [label="Loop 2 Complete\nHandoff to Loop 3", shape=doublecircle,
             fillcolor=green, style="filled,bold"];
  }

  // Connect quality to completion
  test_results -> cleanup [label="Pass"];
  cleanup -> log_completion;
  log_completion -> success;

  // =============================================================================
  // ERROR ESCALATION PATH
  // =============================================================================
  subgraph cluster_errors {
    label="Error Handling & Escalation";
    style="filled,rounded";
    color="red";
    bgcolor="#F8E8E8";

    escalate [shape=hexagon, fillcolor=yellow,
              label="Escalate to User"];
    log_error [label="Log Error Details", fillcolor=orange];
    rollback [label="Rollback Changes", fillcolor=orange];
    failure [label="Loop 2 Failed", shape=doublecircle,
             fillcolor=red, style="filled,bold"];
  }

  // Error escalation flow
  escalate -> log_error;
  quality_gate_fail -> log_error;
  policy_violation -> log_error;
  secrets_violation -> log_error;
  compilation_error -> log_error;
  execution_error -> log_error;

  log_error -> rollback;
  rollback -> failure;

  // =============================================================================
  // LEGEND
  // =============================================================================
  subgraph cluster_legend {
    label="Legend";
    rank=sink;
    style="filled,rounded";
    bgcolor="#F8F8F8";

    legend_start [shape=ellipse, label="Entry Point", fillcolor=lightblue];
    legend_decision [shape=diamond, label="Decision"];
    legend_process [shape=box, label="Process", fillcolor=purple];
    legend_block [shape=octagon, fillcolor=crimson, label="Blocker"];
    legend_warn [shape=octagon, fillcolor=orange, label="Warning"];
    legend_manual [shape=hexagon, fillcolor=yellow, label="Manual"];
    legend_success [shape=doublecircle, fillcolor=green, label="Success"];
    legend_failure [shape=doublecircle, fillcolor=red, label="Failure"];

    legend_start -> legend_decision [style=invis];
    legend_decision -> legend_process [style=invis];
    legend_process -> legend_block [style=invis];
    legend_block -> legend_warn [style=invis];
    legend_warn -> legend_manual [style=invis];
    legend_manual -> legend_success [style=invis];
    legend_success -> legend_failure [style=invis];
  }
}
