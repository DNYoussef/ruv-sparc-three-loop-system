digraph SPARC_INTEGRATION {
  // Layout configuration
  rankdir=TB;
  node [shape=box, style="rounded,filled"];

  // =============================================================================
  // COMMAND INVOCATION
  // =============================================================================
  subgraph cluster_invocation {
    label="Command Invocation: /sparc:integration (System Integrator)";
    style="filled,rounded";
    color="lightblue";
    bgcolor="#E8F4F8";

    invoke [label="User Invokes\n/sparc:integration", shape=ellipse, fillcolor=lightblue];
    parse_args [label="Parse Arguments\n--components <list>\n--validate\n--deploy", fillcolor=lightblue];
    validate_syntax [shape=diamond, label="Syntax\nValid?"];

    syntax_error [shape=octagon, fillcolor=crimson,
                  label="Syntax Error\nShow Usage:\n--components <component_list>\n--validate (run validation)\n--deploy (deploy after integration)"];
  }

  invoke -> parse_args;
  parse_args -> validate_syntax;
  validate_syntax -> syntax_error [label="No"];

  // =============================================================================
  // AUTHENTICATION & AUTHORIZATION
  // =============================================================================
  subgraph cluster_auth {
    label="Authentication & Authorization";
    style="filled,rounded";
    color="orange";
    bgcolor="#FFF8E8";

    check_auth [shape=diamond, label="User\nAuthenticated?"];
    check_integrator [shape=diamond, label="Integrator\nAvailable?"];
    check_permissions [shape=diamond, label="Has Integration\nPermissions?"];

    auth_failed [shape=octagon, fillcolor=crimson,
                 label="Authentication\nFailed"];
    integrator_failed [shape=octagon, fillcolor=crimson,
                       label="Integrator\nNot Available"];
    permission_denied [shape=octagon, fillcolor=crimson,
                       label="Permission\nDenied"];
  }

  validate_syntax -> check_auth [label="Yes"];

  check_auth -> auth_failed [label="No"];
  check_auth -> check_integrator [label="Yes"];

  check_integrator -> integrator_failed [label="No"];
  check_integrator -> check_permissions [label="Yes"];

  check_permissions -> permission_denied [label="No"];

  // =============================================================================
  // PRE-EXECUTION VALIDATION
  // =============================================================================
  subgraph cluster_pre_execution {
    label="Pre-Execution Validation";
    style="filled,rounded";
    color="yellow";
    bgcolor="#FFFCE8";

    validate_components [shape=diamond, label="Components\nAvailable?"];
    validate_dependencies [shape=diamond, label="Dependencies\nResolved?"];
    validate_versions [shape=diamond, label="Version\nCompatibility?"];
    validate_environment [shape=diamond, label="Environment\nReady?"];

    component_error [shape=octagon, fillcolor=orange,
                     label="Components\nMissing"];
    dependency_error [shape=octagon, fillcolor=orange,
                      label="Dependency\nConflicts"];
    version_error [shape=octagon, fillcolor=orange,
                   label="Version\nIncompatibility"];
    environment_error [shape=octagon, fillcolor=orange,
                       label="Environment\nNot Ready"];
  }

  check_permissions -> validate_components [label="Yes"];

  validate_components -> component_error [label="No"];
  validate_components -> validate_dependencies [label="Yes"];

  validate_dependencies -> dependency_error [label="No"];
  validate_dependencies -> validate_versions [label="Yes"];

  validate_versions -> version_error [label="No"];
  validate_versions -> validate_environment [label="Yes"];

  validate_environment -> environment_error [label="No"];

  // =============================================================================
  // COMPONENT DISCOVERY
  // =============================================================================
  subgraph cluster_discovery {
    label="Component Discovery";
    style="filled,rounded";
    color="purple";
    bgcolor="#F0E8F8";

    scan_project [label="Scan Project\nStructure", fillcolor=purple];
    discover_modules [label="Discover\nModules", fillcolor=purple];
    discover_services [label="Discover\nServices", fillcolor=purple];
    discover_apis [label="Discover\nAPIs", fillcolor=purple];

    map_dependencies [label="Map\nDependencies", fillcolor=purple, style="filled,bold"];
    create_dependency_graph [label="Create Dependency\nGraph", fillcolor=purple];

    detect_cycles [shape=diamond, label="Circular\nDependencies?"];

    cycle_error [shape=octagon, fillcolor=orange,
                 label="Circular Dependency\nDetected"];

    prioritize_components [label="Prioritize Component\nIntegration Order", fillcolor=purple];
  }

  validate_environment -> scan_project [label="Yes"];

  scan_project -> discover_modules;
  discover_modules -> discover_services;
  discover_services -> discover_apis;
  discover_apis -> map_dependencies;

  map_dependencies -> create_dependency_graph;
  create_dependency_graph -> detect_cycles;

  detect_cycles -> cycle_error [label="Yes"];
  cycle_error -> map_dependencies [label="Resolve", style=dashed];

  detect_cycles -> prioritize_components [label="No"];

  // =============================================================================
  // INTERFACE VALIDATION
  // =============================================================================
  subgraph cluster_interface_validation {
    label="Interface Validation";
    style="filled,rounded";
    color="blue";
    bgcolor="#E8F0FF";

    extract_interfaces [label="Extract\nInterfaces", fillcolor=lightblue];
    validate_contracts [label="Validate\nContracts", fillcolor=lightblue, style="filled,bold"];

    check_signatures [label="Check Method\nSignatures", fillcolor=lightblue];
    check_types [label="Check Data\nTypes", fillcolor=lightblue];
    check_protocols [label="Check Communication\nProtocols", fillcolor=lightblue];

    interface_mismatch [shape=diamond, label="Interface\nMismatch?"];

    mismatch_error [shape=octagon, fillcolor=orange,
                    label="Interface Mismatch\nFound"];

    generate_adapters [label="Generate\nAdapters", fillcolor=lightblue];
    apply_adapters [label="Apply\nAdapters", fillcolor=lightblue];
  }

  prioritize_components -> extract_interfaces;

  extract_interfaces -> validate_contracts;
  validate_contracts -> check_signatures;
  check_signatures -> check_types;
  check_types -> check_protocols;
  check_protocols -> interface_mismatch;

  interface_mismatch -> mismatch_error [label="Yes"];

  mismatch_error -> generate_adapters;
  generate_adapters -> apply_adapters;
  apply_adapters -> check_signatures [style=dashed];

  // =============================================================================
  // COMPONENT MERGING
  // =============================================================================
  subgraph cluster_merging {
    label="Component Merging";
    style="filled,rounded";
    color="green";
    bgcolor="#E8F8E8";

    merge_strategy [shape=diamond, label="Merge\nStrategy?"];

    incremental_merge [label="Incremental\nMerge", fillcolor=lightgreen];
    big_bang_merge [label="Big Bang\nMerge", fillcolor=lightgreen];
    modular_merge [label="Modular\nMerge", fillcolor=lightgreen];

    merge_source [label="Merge Source\nFiles", fillcolor=lightgreen];
    merge_configs [label="Merge Configuration\nFiles", fillcolor=lightgreen];
    merge_assets [label="Merge\nAssets", fillcolor=lightgreen];

    resolve_conflicts [label="Resolve\nConflicts", fillcolor=lightgreen, style="filled,bold"];

    conflicts_found [shape=diamond, label="Conflicts\nFound?"];

    manual_resolve [shape=hexagon, fillcolor=yellow,
                    label="Manual Conflict\nResolution"];

    merge_complete [label="Merge\nComplete", fillcolor=lightgreen];
  }

  interface_mismatch -> merge_strategy [label="No"];

  merge_strategy -> incremental_merge [label="incremental"];
  merge_strategy -> big_bang_merge [label="big-bang"];
  merge_strategy -> modular_merge [label="modular"];

  incremental_merge -> merge_source;
  big_bang_merge -> merge_source;
  modular_merge -> merge_source;

  merge_source -> merge_configs;
  merge_configs -> merge_assets;
  merge_assets -> resolve_conflicts;

  resolve_conflicts -> conflicts_found;

  conflicts_found -> manual_resolve [label="Yes"];
  manual_resolve -> resolve_conflicts [style=dashed];

  conflicts_found -> merge_complete [label="No"];

  // =============================================================================
  // INTEGRATION TESTING
  // =============================================================================
  subgraph cluster_integration_testing {
    label="Integration Testing";
    style="filled,rounded";
    color="purple";
    bgcolor="#F8F0FF";

    setup_test_env [label="Setup Test\nEnvironment", fillcolor=lightpurple];

    run_component_tests [label="Run Component\nTests", fillcolor=lightpurple];
    run_integration_tests [label="Run Integration\nTests", fillcolor=lightpurple, style="filled,bold"];
    run_api_tests [label="Run API\nTests", fillcolor=lightpurple];
    run_contract_tests [label="Run Contract\nTests", fillcolor=lightpurple];

    integration_tests_pass [shape=diamond, label="Integration Tests\nPass?"];

    analyze_failures [label="Analyze Test\nFailures", fillcolor=yellow];
    identify_root_cause [label="Identify Root\nCause", fillcolor=yellow];

    fix_integration [label="Fix Integration\nIssues", fillcolor=yellow];

    rerun_tests [label="Rerun\nTests", fillcolor=lightpurple];
  }

  merge_complete -> setup_test_env;

  setup_test_env -> run_component_tests;
  run_component_tests -> run_integration_tests;
  run_integration_tests -> run_api_tests;
  run_api_tests -> run_contract_tests;
  run_contract_tests -> integration_tests_pass;

  integration_tests_pass -> analyze_failures [label="No"];
  analyze_failures -> identify_root_cause;
  identify_root_cause -> fix_integration;
  fix_integration -> rerun_tests;
  rerun_tests -> integration_tests_pass [style=dashed];

  // =============================================================================
  // END-TO-END TESTING
  // =============================================================================
  subgraph cluster_e2e_testing {
    label="End-to-End Testing";
    style="filled,rounded";
    color="blue";
    bgcolor="#E8F0FF";

    setup_e2e_env [label="Setup E2E\nEnvironment", fillcolor=lightblue];

    define_workflows [label="Define User\nWorkflows", fillcolor=lightblue];
    prepare_test_data [label="Prepare Test\nData", fillcolor=lightblue];

    run_e2e_tests [label="Run End-to-End\nTests", fillcolor=lightblue, style="filled,bold"];

    test_critical_paths [label="Test Critical\nPaths", fillcolor=lightblue];
    test_edge_cases [label="Test Edge\nCases", fillcolor=lightblue];
    test_error_scenarios [label="Test Error\nScenarios", fillcolor=lightblue];

    e2e_tests_pass [shape=diamond, label="E2E Tests\nPass?"];

    e2e_failures [label="Analyze E2E\nFailures", fillcolor=yellow];
    fix_e2e [label="Fix E2E\nIssues", fillcolor=yellow];

    rerun_e2e [label="Rerun E2E\nTests", fillcolor=lightblue];
  }

  integration_tests_pass -> setup_e2e_env [label="Yes"];

  setup_e2e_env -> define_workflows;
  define_workflows -> prepare_test_data;
  prepare_test_data -> run_e2e_tests;

  run_e2e_tests -> test_critical_paths;
  test_critical_paths -> test_edge_cases;
  test_edge_cases -> test_error_scenarios;
  test_error_scenarios -> e2e_tests_pass;

  e2e_tests_pass -> e2e_failures [label="No"];
  e2e_failures -> fix_e2e;
  fix_e2e -> rerun_e2e;
  rerun_e2e -> e2e_tests_pass [style=dashed];

  // =============================================================================
  // PERFORMANCE TESTING
  // =============================================================================
  subgraph cluster_performance {
    label="Performance Testing";
    style="filled,rounded";
    color="green";
    bgcolor="#E8F8E8";

    setup_perf_env [label="Setup Performance\nEnvironment", fillcolor=lightgreen];

    load_testing [label="Load\nTesting", fillcolor=lightgreen];
    stress_testing [label="Stress\nTesting", fillcolor=lightgreen];
    endurance_testing [label="Endurance\nTesting", fillcolor=lightgreen];

    measure_metrics [label="Measure\nMetrics", fillcolor=lightgreen, style="filled,bold"];

    performance_acceptable [shape=diamond, label="Performance\nAcceptable?"];

    identify_bottlenecks [label="Identify\nBottlenecks", fillcolor=yellow];
    optimize_performance [label="Optimize\nPerformance", fillcolor=yellow];

    rerun_perf_tests [label="Rerun Performance\nTests", fillcolor=lightgreen];
  }

  e2e_tests_pass -> setup_perf_env [label="Yes"];

  setup_perf_env -> load_testing;
  load_testing -> stress_testing;
  stress_testing -> endurance_testing;
  endurance_testing -> measure_metrics;
  measure_metrics -> performance_acceptable;

  performance_acceptable -> identify_bottlenecks [label="No"];
  identify_bottlenecks -> optimize_performance;
  optimize_performance -> rerun_perf_tests;
  rerun_perf_tests -> performance_acceptable [style=dashed];

  // =============================================================================
  // VALIDATION GATES
  // =============================================================================
  subgraph cluster_validation_gates {
    label="Validation Gates";
    style="filled,rounded";
    color="red";
    bgcolor="#FFE8E8";

    gate_security [shape=diamond, label="Security\nGate Pass?"];
    gate_quality [shape=diamond, label="Quality\nGate Pass?"];
    gate_coverage [shape=diamond, label="Coverage\nGate Pass?"];
    gate_documentation [shape=diamond, label="Documentation\nGate Pass?"];

    security_gate_fail [shape=octagon, fillcolor=red,
                        label="Security Gate\nFailed"];
    quality_gate_fail [shape=octagon, fillcolor=orange,
                       label="Quality Gate\nFailed"];
    coverage_gate_fail [shape=octagon, fillcolor=orange,
                        label="Coverage Gate\nFailed"];
    docs_gate_fail [shape=octagon, fillcolor=orange,
                    label="Documentation Gate\nFailed"];

    all_gates_passed [label="All Validation\nGates Passed", fillcolor=lightgreen];
  }

  performance_acceptable -> gate_security [label="Yes"];

  gate_security -> security_gate_fail [label="No"];
  security_gate_fail -> fix_integration [label="Fix Security", style=dashed];

  gate_security -> gate_quality [label="Yes"];

  gate_quality -> quality_gate_fail [label="No"];
  quality_gate_fail -> fix_integration [label="Fix Quality", style=dashed];

  gate_quality -> gate_coverage [label="Yes"];

  gate_coverage -> coverage_gate_fail [label="No"];
  coverage_gate_fail -> run_integration_tests [label="Add Tests", style=dashed];

  gate_coverage -> gate_documentation [label="Yes"];

  gate_documentation -> docs_gate_fail [label="No"];
  gate_documentation -> all_gates_passed [label="Yes"];

  // =============================================================================
  // DEPLOYMENT READINESS
  // =============================================================================
  subgraph cluster_deployment_readiness {
    label="Deployment Readiness";
    style="filled,rounded";
    color="purple";
    bgcolor="#F8F0FF";

    generate_artifacts [label="Generate Build\nArtifacts", fillcolor=lightpurple];

    package_application [label="Package\nApplication", fillcolor=lightpurple];
    create_containers [label="Create\nContainers", fillcolor=lightpurple];

    generate_deployment_config [label="Generate Deployment\nConfiguration", fillcolor=lightpurple];

    create_checklist [label="Create Deployment\nChecklist", fillcolor=lightpurple, style="filled,bold"];

    validate_artifacts [shape=diamond, label="Artifacts\nValid?"];

    artifact_error [shape=octagon, fillcolor=orange,
                    label="Artifact\nValidation Failed"];

    deployment_ready [label="System\nDeployment Ready", fillcolor=lightgreen];
  }

  all_gates_passed -> generate_artifacts;

  generate_artifacts -> package_application;
  package_application -> create_containers;
  create_containers -> generate_deployment_config;
  generate_deployment_config -> create_checklist;
  create_checklist -> validate_artifacts;

  validate_artifacts -> artifact_error [label="No"];
  artifact_error -> generate_artifacts [style=dashed];

  validate_artifacts -> deployment_ready [label="Yes"];

  // =============================================================================
  // OUTPUT & REPORTING
  // =============================================================================
  subgraph cluster_output {
    label="Output & Reporting";
    style="filled,rounded";
    color="blue";
    bgcolor="#E8F0FF";

    generate_report [label="Generate Integration\nReport", fillcolor=lightblue, style="filled,bold"];

    include_test_results [label="Include Test\nResults", fillcolor=lightblue];
    include_metrics [label="Include\nMetrics", fillcolor=lightblue];
    include_coverage [label="Include Coverage\nReport", fillcolor=lightblue];

    format_report [label="Format\nReport", fillcolor=lightblue];
    display_report [label="Display\nReport", fillcolor=lightblue];
  }

  deployment_ready -> generate_report;

  generate_report -> include_test_results;
  include_test_results -> include_metrics;
  include_metrics -> include_coverage;
  include_coverage -> format_report;
  format_report -> display_report;

  // =============================================================================
  // LOGGING & METRICS
  // =============================================================================
  subgraph cluster_logging {
    label="Logging & Metrics";
    style="filled,rounded";
    color="orange";
    bgcolor="#FFF8E8";

    log_integration [label="Log Integration\nProcess", fillcolor=yellow];
    record_metrics [label="Record Integration\nMetrics", fillcolor=yellow];

    track_components [label="Track Components\nIntegrated", fillcolor=yellow];
    track_tests [label="Track Test\nResults", fillcolor=yellow];
    track_time [label="Track Integration\nTime", fillcolor=yellow];

    check_telemetry [shape=diamond, label="Telemetry\nEnabled?"];

    send_telemetry [label="Send Telemetry\nData", fillcolor=yellow];
  }

  display_report -> log_integration;

  log_integration -> record_metrics;
  record_metrics -> track_components;
  track_components -> track_tests;
  track_tests -> track_time;
  track_time -> check_telemetry;

  check_telemetry -> send_telemetry [label="Yes"];

  // =============================================================================
  // CLEANUP & COMPLETION
  // =============================================================================
  subgraph cluster_cleanup {
    label="Cleanup & Completion";
    style="filled,rounded";
    color="green";
    bgcolor="#E8F8E8";

    cleanup_temp [label="Cleanup Temp\nFiles", fillcolor=lightgreen];
    teardown_test_env [label="Teardown Test\nEnvironment", fillcolor=lightgreen];
    persist_artifacts [label="Persist\nArtifacts", fillcolor=lightgreen];
    return_status [label="Return Exit\nCode", fillcolor=lightgreen];
    success [label="Integration\nComplete", shape=doublecircle,
             fillcolor=green, style="filled,bold"];
  }

  check_telemetry -> cleanup_temp [label="No"];
  send_telemetry -> cleanup_temp;

  cleanup_temp -> teardown_test_env;
  teardown_test_env -> persist_artifacts;
  persist_artifacts -> return_status;
  return_status -> success;

  // =============================================================================
  // ERROR HANDLING & RECOVERY
  // =============================================================================
  subgraph cluster_errors {
    label="Error Handling & Recovery";
    style="filled,rounded";
    color="red";
    bgcolor="#F8E8E8";

    classify_error [shape=diamond, label="Error\nType?"];

    retry_integration [label="Retry\nIntegration", fillcolor=yellow];
    rollback_changes [label="Rollback\nChanges", fillcolor=yellow];

    escalate [shape=hexagon, fillcolor=yellow,
              label="Escalate to\nUser"];

    log_error [label="Log Error\nDetails", fillcolor=orange];
    cleanup_after_error [label="Cleanup After\nError", fillcolor=orange];
    failure [label="Command\nFailed", shape=doublecircle,
             fillcolor=red, style="filled,bold"];
  }

  // Route all errors to classification
  syntax_error -> log_error;
  auth_failed -> log_error;
  integrator_failed -> log_error;
  permission_denied -> log_error;
  component_error -> classify_error;
  dependency_error -> classify_error;
  version_error -> classify_error;
  environment_error -> classify_error;
  cycle_error -> classify_error;
  mismatch_error -> classify_error;
  security_gate_fail -> classify_error;
  quality_gate_fail -> classify_error;
  coverage_gate_fail -> classify_error;
  artifact_error -> classify_error;

  // Error classification and recovery
  classify_error -> retry_integration [label="Transient"];
  classify_error -> rollback_changes [label="Conflict"];
  classify_error -> log_error [label="Fatal"];

  retry_integration -> merge_source [label="Retry", style=dashed];
  rollback_changes -> scan_project [label="Rollback", style=dashed];

  log_error -> cleanup_after_error;
  cleanup_after_error -> escalate;
  escalate -> failure;

  // =============================================================================
  // LEGEND
  // =============================================================================
  subgraph cluster_legend {
    label="Legend";
    rank=sink;
    style="filled,rounded";
    bgcolor="#F8F8F8";

    legend_entry [shape=ellipse, fillcolor=lightblue, label="Entry"];
    legend_process [shape=box, fillcolor=purple, label="Process"];
    legend_decision [shape=diamond, label="Decision"];
    legend_block [shape=octagon, fillcolor=crimson, label="Blocker"];
    legend_warn [shape=octagon, fillcolor=orange, label="Warning"];
    legend_manual [shape=hexagon, fillcolor=yellow, label="Manual"];
    legend_success [shape=doublecircle, fillcolor=green, label="Success"];
    legend_failure [shape=doublecircle, fillcolor=red, label="Failure"];

    legend_entry -> legend_process [style=invis];
    legend_process -> legend_decision [style=invis];
    legend_decision -> legend_block [style=invis];
    legend_block -> legend_warn [style=invis];
    legend_warn -> legend_manual [style=invis];
    legend_manual -> legend_success [style=invis];
    legend_success -> legend_failure [style=invis];
  }
}
