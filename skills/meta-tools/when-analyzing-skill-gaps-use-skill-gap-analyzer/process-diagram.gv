digraph SkillGapAnalyzer {
  // Graph settings
  graph [rankdir=TB, splines=ortho, nodesep=0.5, ranksep=0.8, bgcolor=white]
  node [shape=box, style="rounded,filled", fillcolor=lightblue, fontname="Arial", fontsize=10]
  edge [fontname="Arial", fontsize=9]

  // Start
  start [label="Start\nAnalyze Skill Library", shape=ellipse, fillcolor=lightgreen]

  // Phase 1: Library Inventory
  subgraph cluster_phase1 {
    label="Phase 1: Library Inventory"
    style=filled
    fillcolor=lightyellow

    scan_files [label="Scan All\nSKILL.md Files"]
    parse_yaml [label="Parse YAML\nFrontmatter"]
    extract_metadata [label="Extract Metadata\n(name, tags, complexity)"]
    categorize [label="Categorize Skills\nby Domain/Path"]
    map_capabilities [label="Map Capabilities\nfrom Descriptions"]
    track_agents [label="Track Agent\nUsage Patterns"]
  }

  // Phase 2: Coverage Gap Detection
  subgraph cluster_phase2 {
    label="Phase 2: Coverage Gap Detection"
    style=filled
    fillcolor=lightcyan

    define_domains [label="Define Domain\nMatrix Requirements"]
    check_coverage [label="Check Coverage\nfor Each Domain"]
    calc_percentages [label="Calculate Coverage\nPercentages"]
    identify_missing [label="Identify Missing\nCapabilities"]
    test_scenarios [label="Test Scenario\nExecution Readiness"]
    prioritize_gaps [label="Prioritize Gaps\nby Impact"]
  }

  // Phase 3: Redundancy Detection
  subgraph cluster_phase3 {
    label="Phase 3: Redundancy Detection"
    style=filled
    fillcolor=lavender

    find_duplicates [label="Find Capabilities\nHandled by Multiple"]
    analyze_overlap [label="Analyze Overlap\n(Jaccard Similarity)"]
    identify_collisions [label="Identify Naming\nCollisions"]
    calc_consolidation [label="Calculate\nConsolidation Opps"]
    estimate_savings [label="Estimate Token/\nStorage Savings"]
  }

  // Phase 4: Optimization Analysis
  subgraph cluster_phase4 {
    label="Phase 4: Optimization Analysis"
    style=filled
    fillcolor=lightpink

    spawn_researcher [label="Spawn Researcher\nAgent", shape=hexagon, fillcolor=orange]
    load_metrics [label="Load Usage\nMetrics from Memory"]
    find_underutilized [label="Find Under-Utilized\nSkills (<5%, 90+ days)"]
    find_overcomplex [label="Find Over-Complex\nSkills (tokens, success)"]
    find_composability [label="Find Composability\nImprovements"]
    suggest_deps [label="Suggest Dependency\nOptimizations"]
  }

  // Phase 5: Recommendation Generation
  subgraph cluster_phase5 {
    label="Phase 5: Recommendation Generation"
    style=filled
    fillcolor=lightgoldenrodyellow

    synthesize [label="Synthesize All\nFindings"]
    prioritize_recs [label="Prioritize by\nImpact & Effort"]
    generate_actions [label="Generate Immediate/\nShort/Long-Term Actions"]
    create_detailed [label="Create Detailed\nRecommendations"]
    calc_impact [label="Calculate Expected\nImpact Metrics"]
    format_report [label="Format Comprehensive\nReport"]
  }

  // Decision nodes
  library_size [label="Library\nSize?", shape=diamond, fillcolor=lightyellow]
  analysis_type [label="Analysis\nType?", shape=diamond, fillcolor=lightyellow]

  // Hook integration nodes
  pre_hook [label="Pre-Task Hook\nStart Analysis", shape=parallelogram, fillcolor=lightgray]
  mem_store1 [label="Memory Store\nInventory", shape=parallelogram, fillcolor=lightgray]
  mem_store2 [label="Memory Store\nFindings", shape=parallelogram, fillcolor=lightgray]
  mem_store3 [label="Memory Store\nRecommendations", shape=parallelogram, fillcolor=lightgray]
  post_hook [label="Post-Task Hook\nMetrics & Results", shape=parallelogram, fillcolor=lightgray]

  // Output nodes
  output_inventory [label="Inventory JSON\n{skills, categories,\ncapabilities}", shape=note, fillcolor=white]
  output_gaps [label="Gap Analysis JSON\n{coverage, missing,\nscenarios}", shape=note, fillcolor=white]
  output_redundancy [label="Redundancy Report\n{overlaps, savings,\nconsolidation}", shape=note, fillcolor=white]
  output_optimization [label="Optimization Report\n{underutilized,\novercomplex}", shape=note, fillcolor=white]
  output_report [label="Comprehensive\nGap Analysis Report\n(Markdown)", shape=note, fillcolor=white]

  // End
  end [label="End\nActionable\nRecommendations", shape=ellipse, fillcolor=lightcoral]

  // Main flow
  start -> pre_hook
  pre_hook -> library_size

  // Library size branching
  library_size -> analysis_type [label="Small/Medium/Large"]

  // Analysis type branching
  analysis_type -> scan_files [label="Quick/Comprehensive/Targeted"]

  // Phase 1 flow
  scan_files -> parse_yaml
  parse_yaml -> extract_metadata
  extract_metadata -> categorize
  categorize -> map_capabilities
  map_capabilities -> track_agents
  track_agents -> output_inventory
  track_agents -> mem_store1

  // Phase 2 flow
  mem_store1 -> define_domains
  define_domains -> check_coverage
  check_coverage -> calc_percentages
  calc_percentages -> identify_missing
  identify_missing -> test_scenarios
  test_scenarios -> prioritize_gaps
  prioritize_gaps -> output_gaps

  // Phase 3 flow
  output_gaps -> find_duplicates
  find_duplicates -> analyze_overlap
  analyze_overlap -> identify_collisions
  identify_collisions -> calc_consolidation
  calc_consolidation -> estimate_savings
  estimate_savings -> output_redundancy

  // Phase 4 flow
  output_redundancy -> spawn_researcher
  spawn_researcher -> load_metrics
  load_metrics -> find_underutilized
  find_underutilized -> find_overcomplex
  find_overcomplex -> find_composability
  find_composability -> suggest_deps
  suggest_deps -> output_optimization
  suggest_deps -> mem_store2

  // Phase 5 flow
  mem_store2 -> synthesize
  synthesize -> prioritize_recs
  prioritize_recs -> generate_actions
  generate_actions -> create_detailed
  create_detailed -> calc_impact
  calc_impact -> format_report
  format_report -> output_report
  format_report -> mem_store3

  // Final flow
  mem_store3 -> post_hook
  post_hook -> end

  // Parallel data flow (dotted lines for clarity)
  output_inventory -> synthesize [style=dotted, color=gray]
  output_gaps -> synthesize [style=dotted, color=gray]
  output_redundancy -> synthesize [style=dotted, color=gray]
  output_optimization -> synthesize [style=dotted, color=gray]

  // Legend
  subgraph cluster_legend {
    label="Legend"
    style=filled
    fillcolor=white

    leg_phase [label="Process Step", shape=box, style="rounded,filled", fillcolor=lightblue]
    leg_decision [label="Decision Point", shape=diamond, fillcolor=lightyellow]
    leg_agent [label="Agent Spawn", shape=hexagon, fillcolor=orange]
    leg_hook [label="Hook Integration", shape=parallelogram, fillcolor=lightgray]
    leg_output [label="Output Artifact", shape=note, fillcolor=white]
    leg_data [label="Data Flow", style=dotted, color=gray]
  }
}
