digraph PromptOptimizationAnalyzer {
  // Graph settings
  graph [rankdir=TB, splines=ortho, nodesep=0.5, ranksep=0.8, bgcolor=white]
  node [shape=box, style="rounded,filled", fillcolor=lightblue, fontname="Arial", fontsize=10]
  edge [fontname="Arial", fontsize=9]

  // Start
  start [label="Start\nPrompt to Analyze", shape=ellipse, fillcolor=lightgreen]

  // Phase 1: Token Waste Detection
  subgraph cluster_phase1 {
    label="Phase 1: Token Waste Detection"
    style=filled
    fillcolor=lightyellow

    token_count [label="Count Total\nWords & Tokens"]
    detect_repetition [label="Detect Phrase\nRepetition (3+)"]
    measure_verbosity [label="Measure Avg\nWord Length"]
    identify_filler [label="Identify\nFiller Words"]
    calculate_scores [label="Calculate\nRedundancy/Verbosity\nScores"]
  }

  // Phase 2: Anti-Pattern Detection
  subgraph cluster_phase2 {
    label="Phase 2: Anti-Pattern Detection"
    style=filled
    fillcolor=lightcyan

    scan_vague [label="Scan for Vague\nInstructions"]
    check_undefined [label="Check Undefined\nTechnical Terms"]
    identify_conflicts [label="Identify\nConflicting Requirements"]
    detect_missing [label="Detect Missing\nContext"]
    flag_overspec [label="Flag\nOver-Specification"]
  }

  // Phase 3: Trigger Analysis
  subgraph cluster_phase3 {
    label="Phase 3: Trigger Analysis"
    style=filled
    fillcolor=lavender

    check_conditions [label="Check Explicit\nConditions (when/if)"]
    verify_specificity [label="Verify Specificity\n(no vague terms)"]
    assess_scope [label="Assess Scope\n(narrow/broad)"]
    evaluate_coverage [label="Evaluate Edge\nCase Coverage"]
  }

  // Phase 4: Optimization Recommendations
  subgraph cluster_phase4 {
    label="Phase 4: Optimization Recommendations"
    style=filled
    fillcolor=lightpink

    spawn_analyzer [label="Spawn Code\nAnalyzer Agent", shape=hexagon, fillcolor=orange]
    review_issues [label="Review All\nDetected Issues"]
    prioritize [label="Prioritize by\nSeverity & Impact"]
    generate_recs [label="Generate Specific\nRecommendations"]
    create_examples [label="Create Before/After\nExamples"]
    calc_savings [label="Calculate Token\nSavings Estimate"]
  }

  // Phase 5: Before/After Comparison
  subgraph cluster_phase5 {
    label="Phase 5: Before/After Comparison"
    style=filled
    fillcolor=lightgoldenrodyellow

    extract_diffs [label="Extract Key\nDifferences"]
    highlight_improvements [label="Highlight\nImprovements"]
    calc_actual [label="Calculate Actual\nSavings"]
    generate_report [label="Generate\nComparison Report"]
  }

  // Decision nodes
  budget_issue [label="Token Budget\nIssue?", shape=diamond, fillcolor=lightyellow]
  complexity [label="Complexity\nLevel?", shape=diamond, fillcolor=lightyellow]
  audience [label="Target\nAudience?", shape=diamond, fillcolor=lightyellow]

  // Hook integration nodes
  pre_hook [label="Pre-Task Hook\nStore Original Metrics", shape=parallelogram, fillcolor=lightgray]
  mem_store1 [label="Memory Store\nToken Analysis", shape=parallelogram, fillcolor=lightgray]
  mem_store2 [label="Memory Store\nRecommendations", shape=parallelogram, fillcolor=lightgray]
  mem_store3 [label="Memory Store\nFinal Metrics", shape=parallelogram, fillcolor=lightgray]
  post_hook [label="Post-Task Hook\nSavings & Quality", shape=parallelogram, fillcolor=lightgray]

  // Output nodes
  output_analysis [label="Token Waste\nAnalysis JSON", shape=note, fillcolor=white]
  output_patterns [label="Anti-Pattern\nReport JSON", shape=note, fillcolor=white]
  output_triggers [label="Trigger Issues\nJSON", shape=note, fillcolor=white]
  output_recs [label="Optimization\nRecommendations MD", shape=note, fillcolor=white]
  output_comparison [label="Before/After\nComparison Report", shape=note, fillcolor=white]

  // End
  end [label="End\nOptimized Prompt +\nMetrics", shape=ellipse, fillcolor=lightcoral]

  // Main flow
  start -> pre_hook
  pre_hook -> token_count

  // Phase 1 flow
  token_count -> detect_repetition
  detect_repetition -> measure_verbosity
  measure_verbosity -> identify_filler
  identify_filler -> calculate_scores
  calculate_scores -> output_analysis
  calculate_scores -> mem_store1

  // Phase 2 flow
  mem_store1 -> scan_vague
  scan_vague -> check_undefined
  check_undefined -> identify_conflicts
  identify_conflicts -> detect_missing
  detect_missing -> flag_overspec
  flag_overspec -> output_patterns

  // Phase 3 flow
  output_patterns -> check_conditions
  check_conditions -> verify_specificity
  verify_specificity -> assess_scope
  assess_scope -> evaluate_coverage
  evaluate_coverage -> output_triggers

  // Decision flow
  output_triggers -> budget_issue
  budget_issue -> complexity [label="Yes/No"]
  complexity -> audience [label="Simple/Medium/Complex"]

  // Phase 4 flow
  audience -> spawn_analyzer [label="AI/Human/Mixed"]
  spawn_analyzer -> review_issues
  review_issues -> prioritize
  prioritize -> generate_recs
  generate_recs -> create_examples
  create_examples -> calc_savings
  calc_savings -> output_recs
  calc_savings -> mem_store2

  // Phase 5 flow
  mem_store2 -> extract_diffs
  extract_diffs -> highlight_improvements
  highlight_improvements -> calc_actual
  calc_actual -> generate_report
  generate_report -> output_comparison
  generate_report -> mem_store3

  // Final flow
  mem_store3 -> post_hook
  post_hook -> end

  // Legend
  subgraph cluster_legend {
    label="Legend"
    style=filled
    fillcolor=white

    leg_phase [label="Process Step", shape=box, style="rounded,filled", fillcolor=lightblue]
    leg_decision [label="Decision Point", shape=diamond, fillcolor=lightyellow]
    leg_agent [label="Agent Spawn", shape=hexagon, fillcolor=orange]
    leg_hook [label="Hook Integration", shape=parallelogram, fillcolor=lightgray]
    leg_output [label="Output Artifact", shape=note, fillcolor=white]
  }
}
