digraph WorkflowAutomationProcess {
    rankdir=TB;
    compound=true;
    node [shape=box, style=filled, fontname="Arial"];
    edge [fontname="Arial"];

    // Start and end
    start [shape=ellipse, label="Start:\nWorkflow Request", fillcolor=lightgreen];
    end [shape=ellipse, label="Complete:\nOptimized Pipeline", fillcolor=green, fontcolor=white];

    // Requirements analysis
    subgraph cluster_analysis {
        label="Phase 1: Requirements Analysis";
        fillcolor=lightyellow;
        style=filled;

        init_mesh [label="Initialize Mesh\nSwarm"];
        analyze_project [label="CI/CD Engineer:\nAnalyze Project Structure"];
        define_stages [label="Define Pipeline\nStages"];

        init_mesh -> analyze_project;
        analyze_project -> define_stages;
    }

    // Parallel development
    subgraph cluster_development {
        label="Phase 2: Parallel Workflow Development";
        fillcolor=lightblue;
        style=filled;

        base_workflow [label="CI/CD Engineer:\nGenerate Base Workflow"];
        test_strategy [label="Test Engineer:\nDesign Test Orchestration"];
        security_harden [label="Security Auditor:\nSecurity Hardening"];
        optimize_perf [label="Performance Analyzer:\nOptimize Execution"];
        deploy_config [label="Workflow Automation:\nDeployment Automation"];

        base_workflow -> test_strategy [style=dashed, label="parallel"];
        test_strategy -> security_harden [style=dashed, label="parallel"];
        security_harden -> optimize_perf [style=dashed, label="parallel"];
        optimize_perf -> deploy_config [style=dashed, label="parallel"];
    }

    // Integration phase
    subgraph cluster_integration {
        label="Phase 3: Workflow Integration";
        fillcolor=lightcoral;
        style=filled;

        synthesize [label="CI/CD Engineer:\nSynthesize Components"];
        validate_yaml [label="Validate YAML\nSyntax"];
        test_local [label="Test Locally\n(act tool)"];
        create_pr [label="Create PR with\nWorkflow"];
        monitor_first [label="Monitor First\nExecution"];

        synthesize -> validate_yaml;
        validate_yaml -> test_local;
        test_local -> create_pr;
        create_pr -> monitor_first;
    }

    // Optimization workflow
    subgraph cluster_optimize {
        label="Workflow: Optimize Existing";
        fillcolor=lightsalmon;
        style=filled;

        collect_metrics [label="Collect Workflow\nExecution History"];
        identify_bottlenecks [label="Performance Analyzer:\nIdentify Bottlenecks"];
        impl_caching [label="Implement\nCaching Strategy"];
        parallelize [label="Parallelize\nIndependent Jobs"];
        add_filters [label="Add Path\nFiltering"];
        measure_improvement [label="Measure\nImprovement"];

        collect_metrics -> identify_bottlenecks;
        identify_bottlenecks -> impl_caching;
        impl_caching -> parallelize;
        parallelize -> add_filters;
        add_filters -> measure_improvement;
    }

    // Debug workflow
    subgraph cluster_debug {
        label="Workflow: Debug Failing";
        fillcolor=lightgreen;
        style=filled;

        fetch_failure [label="Fetch Failed\nRun Details"];
        analyze_failure [label="CI/CD Engineer:\nAnalyze Failure Pattern"];
        reproduce_local [label="Reproduce Locally\n(act tool)"];
        add_debug [label="Add Debug\nLogging"];
        apply_fix [label="Apply Fix\n(Retry/Timeout/Deps)"];
        validate_fix [label="Validate Fix\nin GitHub"];

        fetch_failure -> analyze_failure;
        analyze_failure -> reproduce_local;
        reproduce_local -> add_debug;
        add_debug -> apply_fix;
        apply_fix -> validate_fix;
    }

    // Advanced patterns
    subgraph cluster_advanced {
        label="Advanced Patterns";
        fillcolor=lightyellow;
        style=filled;

        matrix_testing [label="Matrix Testing:\nOS Ã— Runtime Versions"];
        reusable_workflows [label="Reusable\nWorkflows"];
        composite_actions [label="Composite\nActions"];
        conditional_exec [label="Conditional\nExecution"];

        matrix_testing -> reusable_workflows [style=dashed];
        reusable_workflows -> composite_actions [style=dashed];
        composite_actions -> conditional_exec [style=dashed];
    }

    // Decision points
    project_type [shape=diamond, label="Project\nType?", fillcolor=yellow];
    workflow_exists [shape=diamond, label="Workflow\nExists?", fillcolor=yellow];
    optimization_needed [shape=diamond, label="Optimization\nNeeded?", fillcolor=yellow];
    tests_pass [shape=diamond, label="Tests\nPass?", fillcolor=yellow];

    // External tools
    mcp_mesh [shape=cylinder, label="MCP Swarm:\nMesh Topology\nPeer Collaboration", fillcolor=lightcoral];
    workflow_templates [shape=cylinder, label="Workflow Templates:\nNode, Python, Rust\nGo, Java", fillcolor=lightcoral];
    act_tool [shape=cylinder, label="act tool:\nLocal GitHub Actions\nTesting", fillcolor=lightcoral];

    // Main flow
    start -> init_mesh;
    define_stages -> workflow_exists;

    workflow_exists -> project_type [label="no:\nnew workflow"];
    workflow_exists -> collect_metrics [lhead=cluster_optimize, label="yes:\noptimize"];

    // New workflow creation
    project_type -> base_workflow [lhead=cluster_development, label="detected"];

    deploy_config -> synthesize [lhead=cluster_integration];

    monitor_first -> tests_pass;
    tests_pass -> optimization_needed [label="pass"];
    tests_pass -> fetch_failure [lhead=cluster_debug, label="fail", color=red];

    // Optimization path
    measure_improvement -> optimization_needed;
    optimization_needed -> end [label="satisfied"];
    optimization_needed -> identify_bottlenecks [label="more gains", style=dashed];

    // Debug path
    validate_fix -> tests_pass;

    // Advanced patterns integration
    monitor_first -> matrix_testing [lhead=cluster_advanced, style=dashed, label="enhance"];
    conditional_exec -> end [style=dashed];

    // External tool usage
    init_mesh -> mcp_mesh [style=dashed, label="uses", dir=both];
    base_workflow -> workflow_templates [style=dashed, label="uses"];
    test_local -> act_tool [style=dashed, label="uses"];
    reproduce_local -> act_tool [style=dashed, label="uses"];

    // Security best practices
    pin_versions [shape=octagon, label="CRITICAL:\nPin Actions to SHA\nNot Tags", fillcolor=red, fontcolor=white];
    min_perms [shape=octagon, label="ENFORCE:\nMinimal GITHUB_TOKEN\nPermissions", fillcolor=orange];

    security_harden -> pin_versions [style=dashed, color=red];
    security_harden -> min_perms [style=dashed, color=orange];

    pin_versions -> deploy_config [label="enforced", color=red];
    min_perms -> deploy_config [label="enforced", color=orange];

    // Performance optimizations
    caching_strategy [shape=folder, label="Caching:\nDependencies\nBuild Artifacts\nDocker Layers", fillcolor=lightyellow];
    parallel_strategy [shape=folder, label="Parallelization:\nIndependent Jobs\nMatrix Testing\nSelective Execution", fillcolor=lightyellow];

    optimize_perf -> caching_strategy [style=dashed, label="implements"];
    impl_caching -> caching_strategy [style=dashed, label="applies"];

    optimize_perf -> parallel_strategy [style=dashed, label="implements"];
    parallelize -> parallel_strategy [style=dashed, label="applies"];

    // Common failure modes
    flaky_tests [shape=octagon, label="WARNING:\nFlaky Tests\nDetected", fillcolor=yellow];
    timeout [shape=octagon, label="ERROR:\nJob Timeout", fillcolor=orange];

    analyze_failure -> flaky_tests [style=dashed, label="intermittent"];
    analyze_failure -> timeout [style=dashed, label="slow jobs"];

    flaky_tests -> apply_fix [label="add retry logic", color=orange];
    timeout -> apply_fix [label="increase timeout", color=orange];

    labelloc="t";
    label="GitHub Actions Workflow Automation: Parallel Development, Optimization, and Security Hardening";
    fontsize=16;
    fontname="Arial Bold";
}
