digraph PerformanceProfilerProcess {
  // Graph settings
  rankdir=TB;
  node [shape=box, style="rounded,filled", fontname="Arial", fontsize=10];
  edge [fontname="Arial", fontsize=9];

  // Color scheme
  node [fillcolor="#E3F2FD"];

  // Input
  input [label="Input\n(Application + Workload)", shape=ellipse, fillcolor="#C8E6C9"];

  // Phase 1: Baseline
  subgraph cluster_baseline {
    label="Phase 1: Baseline & Initialization";
    style=filled;
    fillcolor="#FFF3E0";

    setup [label="1.1 Environment\nSetup"];
    baseline [label="1.2 Baseline\nMeasurement"];
    budget [label="1.3 Performance\nBudget"];
  }

  // Phase 2: Detection (Parallel)
  subgraph cluster_detection {
    label="Phase 2: Bottleneck Detection (Parallel)";
    style=filled;
    fillcolor="#FFEBEE";

    cpu_profile [label="2.1 CPU\nProfiling"];
    mem_profile [label="2.2 Memory\nProfiling"];
    io_profile [label="2.3 I/O\nProfiling"];
    net_profile [label="2.4 Network\nProfiling"];
  }

  // Phase 3: Analysis
  subgraph cluster_analysis {
    label="Phase 3: Root Cause Analysis";
    style=filled;
    fillcolor="#E8F5E9"];

    correlate [label="3.1 Correlation\nAnalysis"];
    impact [label="3.2 Impact\nAssessment"];
    prioritize [label="3.3 Prioritization"];
  }

  // Phase 4: Optimization
  subgraph cluster_optimization {
    label="Phase 4: Optimization Generation";
    style=filled;
    fillcolor="#F3E5F5"];

    algo_opt [label="4.1 Algorithmic\nOptimizations"];
    cache_opt [label="4.2 Caching\nStrategies"];
    parallel_opt [label="4.3 Parallelization"];
    db_opt [label="4.4 Database\nOptimizations"];
    mem_opt [label="4.5 Memory\nOptimizations"];
  }

  // Phase 5: Implementation
  subgraph cluster_implementation {
    label="Phase 5: Implementation";
    style=filled;
    fillcolor="#E1F5FE"];

    codegen [label="5.1 Code\nGeneration"];
    db_migration [label="5.2 Database\nMigrations"];
    config [label="5.3 Configuration\nUpdates"];
  }

  // Phase 6: Validation
  subgraph cluster_validation {
    label="Phase 6: Validation & Benchmarking";
    style=filled;
    fillcolor="#FFF9C4"];

    tests [label="6.1 Test\nExecution"];
    benchmark [label="6.2 Benchmark\nExecution"];
    compare [label="6.3 Before/After\nComparison"];
  }

  // Output
  output [label="Output\n(Report + Optimizations + Benchmarks)", shape=ellipse, fillcolor="#C8E6C9"];

  // Main flow
  input -> setup;

  // Phase 1 flow
  setup -> baseline;
  baseline -> budget;

  // Phase 2 flow (parallel from budget)
  budget -> cpu_profile;
  budget -> mem_profile;
  budget -> io_profile;
  budget -> net_profile;

  // Convergence to Phase 3
  cpu_profile -> correlate;
  mem_profile -> correlate;
  io_profile -> correlate;
  net_profile -> correlate;

  // Phase 3 flow
  correlate -> impact;
  impact -> prioritize;

  // Phase 4 flow (parallel from prioritize)
  prioritize -> algo_opt;
  prioritize -> cache_opt;
  prioritize -> parallel_opt;
  prioritize -> db_opt;
  prioritize -> mem_opt;

  // Convergence to Phase 5
  algo_opt -> codegen;
  cache_opt -> codegen;
  parallel_opt -> codegen;
  db_opt -> db_migration;
  mem_opt -> config;

  // Phase 5 convergence
  codegen -> tests;
  db_migration -> tests;
  config -> tests;

  // Phase 6 flow
  tests -> benchmark;
  benchmark -> compare;

  // Final output
  compare -> output;

  // Feedback loop (dotted)
  edge [style=dotted, color=blue];
  compare -> prioritize [label="Regression\ndetected"];

  // Parallel execution indicators (invisible edges for layout)
  edge [style=invis];
  cpu_profile -> mem_profile;
  mem_profile -> io_profile;
  io_profile -> net_profile;

  algo_opt -> cache_opt;
  cache_opt -> parallel_opt;
  parallel_opt -> db_opt;
  db_opt -> mem_opt;

  // Agent coordination (dashed)
  edge [style=dashed, color=green];
  cpu_profile -> mem_profile [label="Coordinate\nvia hooks", style=dashed, constraint=false];
  codegen -> db_migration [label="Share\nmemory", style=dashed, constraint=false];

  // Decision points (diamond)
  decision1 [label="Regressions?", shape=diamond, fillcolor="#FFE082"];
  decision2 [label="Target met?", shape=diamond, fillcolor="#FFE082"];

  edge [style=solid, color=black];
  compare -> decision1;
  decision1 -> decision2 [label="No"];
  decision1 -> prioritize [label="Yes"];
  decision2 -> output [label="Yes"];
  decision2 -> prioritize [label="No\n(iterate)"];

  // Profiling modes (subgraph)
  subgraph cluster_modes {
    label="Profiling Modes";
    style=filled;
    fillcolor="#EEEEEE";
    rank=same;

    quick [label="Quick\n(30s)", shape=note];
    standard [label="Standard\n(5min)", shape=note];
    deep [label="Deep\n(30min)", shape=note];
    continuous [label="Continuous\n(ongoing)", shape=note];
  }

  // Connect modes to detection phase
  edge [style=dashed, color=gray];
  quick -> cpu_profile [constraint=false];
  standard -> cpu_profile [constraint=false];
  deep -> cpu_profile [constraint=false];
  continuous -> cpu_profile [constraint=false];

  // Agents involved (subgraph)
  subgraph cluster_agents {
    label="Claude-Flow Agents";
    style=filled;
    fillcolor="#E8EAF6";
    rank=same;

    agent1 [label="performance-\nanalyzer", shape=octagon, fillcolor="#9FA8DA"];
    agent2 [label="performance-\nbenchmarker", shape=octagon, fillcolor="#9FA8DA"];
    agent3 [label="coder", shape=octagon, fillcolor="#9FA8DA"];
    agent4 [label="optimizer", shape=octagon, fillcolor="#9FA8DA"];
  }

  // Connect agents to phases
  edge [style=dashed, color=purple];
  agent1 -> cpu_profile [constraint=false];
  agent1 -> mem_profile [constraint=false];
  agent4 -> algo_opt [constraint=false];
  agent3 -> codegen [constraint=false];
  agent2 -> benchmark [constraint=false];
}
