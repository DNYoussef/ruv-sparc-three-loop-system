#!/usr/bin/env node

/**
 * Parallel Executor - Dynamic Agent Deployment from Assignment Matrix
 * Part of Loop 2: Parallel Swarm Implementation (Enhanced Tier)
 *
 * This script executes parallel agent deployment based on the agent+skill
 * assignment matrix generated by swarm-coordinator.py.
 */

const fs = require('fs').promises;
const path = require('path');
const { spawn } = require('child_process');

class ParallelExecutor {
  /**
   * Initialize parallel executor with assignment matrix
   * @param {string} matrixPath - Path to agent-skill-assignments.json
   */
  constructor(matrixPath) {
    this.matrixPath = matrixPath;
    this.matrix = null;
    this.executionLog = [];
    this.groupResults = new Map();
  }

  /**
   * Load agent+skill assignment matrix
   */
  async loadMatrix() {
    try {
      const data = await fs.readFile(this.matrixPath, 'utf8');
      this.matrix = JSON.parse(data);
      console.log(`‚úÖ Loaded assignment matrix: ${this.matrix.project}`);
      console.log(`   Total tasks: ${this.matrix.statistics.totalTasks}`);
      console.log(`   Parallel groups: ${this.matrix.parallelGroups.length}`);
    } catch (error) {
      throw new Error(`Failed to load matrix: ${error.message}`);
    }
  }

  /**
   * Execute all parallel groups sequentially
   */
  async executeAllGroups() {
    console.log('\n=== Starting Parallel Group Execution ===\n');

    const totalGroups = this.matrix.parallelGroups.length;

    for (let i = 0; i < totalGroups; i++) {
      const group = this.matrix.parallelGroups[i];
      console.log(`\n${'='.repeat(60)}`);
      console.log(`Executing Parallel Group ${group.group}/${totalGroups}`);
      console.log(`Reason: ${group.reason}`);
      console.log(`Tasks: ${group.tasks.length}`);
      console.log(${'='.repeat(60)}\n`);

      await this.executeParallelGroup(group);

      // Validate group completion
      const queenValidation = await this.queenValidateGroup(group.group);

      if (!queenValidation.success) {
        console.error(`‚ùå Group ${group.group} validation failed`);
        console.error(`   Reason: ${queenValidation.reason}`);
        throw new Error(`Group ${group.group} failed validation - stopping execution`);
      }

      console.log(`‚úÖ Parallel group ${group.group} complete\n`);
    }

    console.log('\n‚úÖ All parallel groups executed successfully');
  }

  /**
   * Execute a single parallel group
   * @param {Object} group - Parallel group from matrix
   */
  async executeParallelGroup(group) {
    const tasks = group.tasks.map(taskId =>
      this.matrix.tasks.find(t => t.taskId === taskId)
    );

    // Spawn all agents in parallel (simulated - actual implementation would use Task tool)
    const agentPromises = tasks.map(task => this.spawnAgent(task));

    // Wait for all agents to complete
    const results = await Promise.all(agentPromises);

    // Store results
    this.groupResults.set(group.group, results);

    // Log summary
    const successful = results.filter(r => r.success).length;
    console.log(`\nGroup ${group.group} Summary:`);
    console.log(`   Successful: ${successful}/${tasks.length}`);
    console.log(`   Failed: ${tasks.length - successful}/${tasks.length}`);
  }

  /**
   * Spawn a single agent for task execution
   * @param {Object} task - Task from assignment matrix
   * @returns {Promise<Object>} Execution result
   */
  async spawnAgent(task) {
    console.log(`\nüöÄ Spawning Agent: ${task.assignedAgent} (${task.taskId})`);
    console.log(`   Description: ${task.description.substring(0, 60)}...`);
    console.log(`   Using Skill: ${task.useSkill || 'Custom Instructions'}`);
    console.log(`   Priority: ${task.priority}`);

    // Check dependencies are complete
    if (task.dependencies.length > 0) {
      console.log(`   Dependencies: ${task.dependencies.join(', ')}`);
      const depsComplete = await this.checkDependenciesComplete(task.dependencies);
      if (!depsComplete) {
        console.log(`   ‚ö†Ô∏è  Dependencies not complete - waiting...`);
        await this.waitForDependencies(task.dependencies);
      }
    }

    // Execute pre-task hooks
    await this.executeHook('pre-task', task);

    // Simulate agent execution (in production, would call Task tool)
    const result = await this.executeTask(task);

    // Execute post-task hooks
    await this.executeHook('post-task', task);

    // Store progress in memory
    await this.storeProgress(task, result);

    this.executionLog.push({
      taskId: task.taskId,
      agent: task.assignedAgent,
      skill: task.useSkill,
      timestamp: new Date().toISOString(),
      result
    });

    if (result.success) {
      console.log(`   ‚úÖ ${task.taskId} completed successfully`);
    } else {
      console.log(`   ‚ùå ${task.taskId} failed: ${result.error}`);
    }

    return result;
  }

  /**
   * Execute a task (simulated - would use Claude Code Task tool in production)
   * @param {Object} task - Task to execute
   * @returns {Promise<Object>} Execution result
   */
  async executeTask(task) {
    // In production, this would use Claude Code's Task tool:
    // Task(task.assignedAgent, task.customInstructions, agentType, { useSkill: task.useSkill })

    // Simulated execution with realistic timing
    const executionTime = Math.random() * 3000 + 1000; // 1-4 seconds

    await new Promise(resolve => setTimeout(resolve, executionTime));

    // Simulate success/failure (95% success rate)
    const success = Math.random() > 0.05;

    return {
      success,
      taskId: task.taskId,
      agent: task.assignedAgent,
      executionTime: Math.round(executionTime),
      error: success ? null : 'Simulated task failure'
    };
  }

  /**
   * Execute coordination hooks
   * @param {string} hookType - Type of hook (pre-task, post-edit, post-task)
   * @param {Object} task - Task context
   */
  async executeHook(hookType, task) {
    // In production, would execute:
    // npx claude-flow@alpha hooks ${hookType} --task-id ${task.taskId}

    console.log(`   üîó Hook: ${hookType} (${task.taskId})`);

    // Simulated hook execution
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  /**
   * Store task progress in memory
   * @param {Object} task - Task
   * @param {Object} result - Execution result
   */
  async storeProgress(task, result) {
    // In production, would execute:
    // npx claude-flow@alpha memory store "${task.taskId}_progress" "${JSON.stringify(result)}" --namespace "swarm/realtime"

    console.log(`   üíæ Stored progress: swarm/realtime/${task.taskId}_progress`);
  }

  /**
   * Check if dependencies are complete
   * @param {Array<string>} dependencies - Task IDs of dependencies
   * @returns {Promise<boolean>} True if all dependencies complete
   */
  async checkDependenciesComplete(dependencies) {
    // Check if all dependency tasks are in execution log as successful
    return dependencies.every(depId => {
      const dep = this.executionLog.find(log => log.taskId === depId);
      return dep && dep.result.success;
    });
  }

  /**
   * Wait for dependencies to complete
   * @param {Array<string>} dependencies - Task IDs to wait for
   */
  async waitForDependencies(dependencies) {
    // Simplified wait - in production would use real-time memory polling
    const maxWait = 30000; // 30 seconds
    const checkInterval = 500; // 500ms
    let elapsed = 0;

    while (elapsed < maxWait) {
      const complete = await this.checkDependenciesComplete(dependencies);
      if (complete) {
        return;
      }

      await new Promise(resolve => setTimeout(resolve, checkInterval));
      elapsed += checkInterval;
    }

    throw new Error(`Dependencies ${dependencies.join(', ')} did not complete within timeout`);
  }

  /**
   * Queen validates group completion
   * @param {number} groupNum - Group number
   * @returns {Promise<Object>} Validation result
   */
  async queenValidateGroup(groupNum) {
    console.log(`\nüëë Queen Coordinator validating group ${groupNum}...`);

    const groupResults = this.groupResults.get(groupNum) || [];

    // Check all tasks successful
    const allSuccessful = groupResults.every(r => r.success);

    if (!allSuccessful) {
      const failed = groupResults.filter(r => !r.success);
      return {
        success: false,
        reason: `${failed.length} task(s) failed in group ${groupNum}`,
        failedTasks: failed.map(r => r.taskId)
      };
    }

    // Check no errors or blocks
    // (In production, would check logs, memory, etc.)

    // Validate inter-task dependencies satisfied
    // (Simplified - already checked during execution)

    console.log(`   ‚úÖ Group ${groupNum} validation passed`);

    return {
      success: true,
      reason: `All tasks in group ${groupNum} completed successfully`
    };
  }

  /**
   * Generate execution summary
   */
  async generateSummary() {
    const summary = {
      matrix: {
        project: this.matrix.project,
        totalTasks: this.matrix.statistics.totalTasks,
        parallelGroups: this.matrix.parallelGroups.length
      },
      execution: {
        totalExecuted: this.executionLog.length,
        successful: this.executionLog.filter(log => log.result.success).length,
        failed: this.executionLog.filter(log => !log.result.success).length,
        totalTime: this.executionLog.reduce((sum, log) => sum + log.result.executionTime, 0)
      },
      groups: Array.from(this.groupResults.entries()).map(([group, results]) => ({
        group,
        tasks: results.length,
        successful: results.filter(r => r.success).length,
        avgTime: Math.round(
          results.reduce((sum, r) => sum + r.executionTime, 0) / results.length
        )
      })),
      timestamp: new Date().toISOString()
    };

    // Save summary
    const summaryPath = path.join(
      path.dirname(this.matrixPath),
      'execution-summary.json'
    );

    await fs.writeFile(summaryPath, JSON.stringify(summary, null, 2));

    console.log('\n=== Execution Summary ===');
    console.log(`Project: ${summary.matrix.project}`);
    console.log(`Total Tasks: ${summary.execution.totalExecuted}/${summary.matrix.totalTasks}`);
    console.log(`Successful: ${summary.execution.successful}`);
    console.log(`Failed: ${summary.execution.failed}`);
    console.log(`Total Time: ${(summary.execution.totalTime / 1000).toFixed(1)}s`);
    console.log(`Average Time per Task: ${(summary.execution.totalTime / summary.execution.totalExecuted / 1000).toFixed(1)}s`);
    console.log(`\nSummary saved: ${summaryPath}`);

    return summary;
  }
}

/**
 * Main entry point
 */
async function main() {
  const args = process.argv.slice(2);

  if (args.length < 1) {
    console.error('Usage: node parallel-executor.js <agent-skill-assignments.json>');
    process.exit(1);
  }

  const matrixPath = args[0];

  console.log('=== Parallel Executor - Loop 2 Dynamic Deployment ===\n');

  const executor = new ParallelExecutor(matrixPath);

  try {
    // Load assignment matrix
    await executor.loadMatrix();

    // Execute all parallel groups
    await executor.executeAllGroups();

    // Generate summary
    await executor.generateSummary();

    console.log('\n‚úÖ Parallel execution complete - ready for Loop 3');
    process.exit(0);
  } catch (error) {
    console.error(`\n‚ùå Execution failed: ${error.message}`);
    console.error(error.stack);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = { ParallelExecutor };
